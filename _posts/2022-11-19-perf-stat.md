# Experimenting with the perf stat command


Linux has a perfomance tool that lets one access hardware counters of
instruction counts, among other stats. Let's give it a try. One of the easiest that I can
think of just returns an errorcode to the shell on exiting.

## C Version
```C
int main(int argc, char* argv[])
{
    return 0;
}
```
which disassembles tvia `gcc -S`) to:
```
main:
.LFB0:
	.cfi_startproc
	endbr64
	movl	$0, %eax
	ret
```

Running `perf stat` on even this simple program results in the execution of
646,399 instructions, even though there are only three effective instructions.
What's going on here? Are we missing some instructions? Does this include the
instructions required to load the program? Why do the number of instructions
vary from run to run?

```
 Performance counter stats for './a.out' (100 runs):

              0.26 msec task-clock                #    0.480 CPUs utilized            ( +-  3.53% )
                 0      context-switches          #    0.000 /sec                   
                 0      cpu-migrations            #    0.000 /sec                   
                44      page-faults               #  150.895 K/sec                    ( +-  0.22% )
           908,925      cycles                    #    3.117 GHz                      ( +-  2.89% )
           646,399      instructions              #    0.66  insn per cycle           ( +-  0.18% )
           128,260      branches                  #  439.859 M/sec                    ( +-  0.18% )
             3,388      branch-misses             #    2.58% of all branches          ( +-  1.60% )

         0.0005323 +- 0.0000176 seconds time elapsed  ( +-  3.31% )
```

As it turns out, this program dynamically links in other libraries. Clearly, it's doing something other than the 3 instructions in the assembly. I believe the linker is including in the C runtime. Besides that, the code is including the `libc` dynamically linked **library**.

```
$ ldd ./a.out
	linux-vdso.so.1 (0x00007fff86bd3000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fb7c95b0000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fb7c97c2000)
```

## x86 Version
Drawing inspiration from http://timelessname.com/elfbin/ where the author created a
very small ELF binary, I wrote the same program in NASM to remove the need for a C runtime.

```
BITS 64

section .text
global _start
_start:
    mov eax,1
    mov ebx,0
    int 80h
```
and assembled using
```
nasm -f elf64 simple.asm
ld simple.o -o ./a.out
strip -s ./a.out
```
And, this time I only monitored the *user* instructions
```
	perf stat -r 100 -e instructions:u -o results.txt ./a.out
```
This time it only recorded 4 instructions. It's more than I expected, but maybe
the `int` instruction counts as 2.
```
 Performance counter stats for './a.out' (100 runs):

                 4      instructions:u                                              

        0.00020050 +- 0.00000418 seconds time elapsed  ( +-  2.08% )
```

## Other Notes

`perf list` lists the available events possible to record on your system.

To start `gdb` and stop at the first instruction, invoke the tool and run the first instruction `start`.
